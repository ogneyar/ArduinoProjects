#include "dht.h"

uint8_t status;// состояние автомата опроса датчика
uint8_t data[5];// массив для приема данных от датчика
uint8_t bit=7;// счетчик битов
uint8_t byte;// счетчик байтов
uint8_t hum, temp;// переменные для хранения текущих температуры и влажности
uint8_t pause;// для отсчета паузы


void dht_ini(void){
	TCCR0|=(1<<CS02)|(1<<CS00);// запуск таймера 0 с делителем 1024
	TIMSK|=(1<<TOIE0);// разрешить прерывания по переполнению таймера 0
}

// обработчик прерывания по переполнению таймера 0
ISR(TIMER0_OVF_vect) {
	switch (status)
	{
		case 0:
		DHT_DDR|=(1<<DHT);// притянуть линию к земле
		TCNT0=100;// пауза 20 мс
		status=1;
		break;
		
		case 1:
		DHT_DDR&=~(1<<DHT);// отпустить линию
		TCCR0=(1<<CS01);// делитель на 8
		TCNT0=216;// пауза 40 мкс
		status=2;
		break;
		
		case 2:
		if (DHT_PIN&(1<<DHT))// проверка линии
		{
			TCCR0=(1<<CS02)|(1<<CS00);// делитель 1024
			pause=153;//заводим таймер на 5 секунд
			status=100;// если налинии 1 ошибка - датчик не отвечает
		} else {
			status=3;
			TCNT0=176;// пауза 80 мкс
		}
		break;
		
		case 3:
		if (!(DHT_PIN&(1<<DHT))) {// проверка линии
			TCCR0=(1<<CS02)|(1<<CS00);// делитель 1024
			pause=153;//заводим таймер на 5 секунд
			status=101;// если на линии 0 ошибка - датчик не начинает передачу
		} else {
			status=4;
			MCUCR|=(1<<ISC11); // прерывание ИНТ1 по спаду
			GICR|=(1<<INT1);// разрешить прерывание ИНТ1
			TIMSK&=~(1<<TOIE0);// запрет прерывания таймера 0
		}
		break;
		
		case 255: case 254:case 100: case 101:
		if (pause)// отсчет 5 секунд между опросами датчика
		{
			pause--;
		} else {
			status=0;
		}
		break;
		
	}
}

// обработчик прерывания ИНТ1
ISR(INT1_vect){
	switch (status)
	{
		case 4:
		MCUCR|=(1<<ISC10);// прерывание ИНТ1 по фронту
		status=5;
		break;
		
		case 5:
		TCNT0=0;// cбросить счетчик таймера в 0
		MCUCR&=~(1<<ISC10);// ИНТ1 по спаду
		status=6;
		break;
		
		case 6:
		if (TCNT0>=60)// если натикало 60 и больше приняли 1
		{
			data[byte]|=(1<<bit);// поднимаем текущий бит текущего байта в 1.
		}
		if (bit)// если бит не последний
		{
			bit--;// тикаем битом
		} else {// если приняли последний бит байта
			bit=7;// начинаем со старшего бита
			byte++;// тикаем байтом
			if (byte>4)// если приняли последний байт
			{
				byte=0; // сбросить счетчик байт в 0
				
				if (data[0]+data[1]+data[2]+data[3]==data[4])// проверка контрольной суммы
				{
					hum=data[0];// влажность
					temp=data[2];// темепература
					status=255;// уходим в "прием успешно закончен"
				} else {
					status=254;// уходим в "прием закончен с ошибкой"
				}
				
				data[0]=data[1]=data[2]=data[3]=data[4]=0;// обнулить массив
								
				TCCR0=(1<<CS02)|(1<<CS00);// делитель 1024
				TCNT0=0;
				TIMSK|=(1<<TOIE0);// разрешить прерывания по переполнению таймера 0
				
				MCUCR&=~(1<<ISC11); // сбросить бит
				GICR&=~(1<<INT1);// запрет прерывания ИНТ1
				
				pause=153;// заводим таймер на 5 секунд
				
				break;				
			}
		}
		MCUCR|=(1<<ISC10);// прерывание ИНТ1 по фронту
		status=5;
		break;
	}
}