#include "UART.h"

//----------- функция отправки байта ------------------------
void bit_bang_tx(unsigned char data) {
	unsigned char i;
	uart_PORT &=~ (1<<uart_PIN);         // старт бит
	TCNT0 = 0;
	while (TCNT0 < uart_delay); // ожидаем
	for (i = 0; i < 8; i++) { // отправка с младщего бита
		if (data & (0x01 << i)) uart_PORT |= (1<<uart_PIN);
		else uart_PORT &=~ (1<<uart_PIN);
		while (TCNT0 < uart_delay); // ожидаем
	}
	uart_PORT |= (1<<uart_PIN);        // стоп бит
	while (TCNT0 < uart_delay); // ожидаем
}
//-----------------------------------------------------------

//------------- фунция отправки строки-----------------------
void bit_bang_tx_str(char *str) {
	while (*str) bit_bang_tx(*str++);
}
//------------------------------------------------------------


//-------------- просто инициализация-------------------------
void uart_init() {
	//-------------- настройка таймера для UART -------------------------
	TCCR0A = 0x02;  // таймер вкючаем в режим CTC
	TCCR0B = 0x02;  // делитель на 8
	OCR0A  = uart_delay; // регистр сравнения
	//-------------------------------------------------------------------
	//-------настройка порта------------------
	uart_DDR |= (1<<uart_PIN);
	uart_PORT |= (1<<uart_PIN);
	//--------------------------------------
}
//-----------------------------------------------------------


// -------------- отправка данных в порт -------------
void uart_print (unsigned int IR_block) {

unsigned char adress;
unsigned char command;
bool exp;
bool chk;
char str[10] = {0}; // массив для строки. обнуленный на всяк.случ.
	
	
adress = (IR_block & 0x1f); // вычленяем последние 5 бит (с 0 по 4) 
command = (IR_block & 0x1FE0)>>5; // вычленяем 8 бит (с 5 по 12) в переменную команд, сдвигаем на 5 вправо иначе ерунда выйдет :)
exp = (IR_block & 0x2000)>>13; // извергаем 1 бит ( 13-й) и сдвигаем на 13 вправо.
chk = (IR_block & 0x4000)>>14; // низвергаем 1 бит ( 14-й) и сдвигаем на 14 вправо.

// выводим всё в порт в виде строки adress#command#exp#chk#IR_block
// пример:
// 1#16#1#0#8897
// 1#e9#0#1#23841
// делителем выступает символ #. adress и command 16-тиричные, exp и chk двоичные, IR_block десятичное.


utoa(adress,str,16); // конвертим адрес в 16-тиричное и записываем АНСии коды в массив стр
bit_bang_tx_str((char *)str); // отправляем массив

utoa(command,str,16); // конвертим команд в 16-тиричное и записываем АНСии коды в массив стр
bit_bang_tx_str("#"); // отправляем в порт текст
bit_bang_tx_str((char *)str); // отправляем массив

utoa(exp,str,2); // конвертим эксп в 2-ичное и записываем АНСии коды в массив стр
bit_bang_tx_str("#"); // отправляем в порт текст
bit_bang_tx_str((char *)str); // отправляем массив

utoa(chk,str,2); // конвертим чек в 2-ичное и записываем АНСии коды в массив стр
bit_bang_tx_str("#"); // отправляем в порт текст
bit_bang_tx_str((char *)str); // отправляем массив

utoa(IR_block,str,10); // конвертим весь блок  в 10-тичное и записываем АНСии коды в массив стр
bit_bang_tx_str("#"); // отправляем в порт текст
bit_bang_tx_str((char *)str); // отправляем массив

bit_bang_tx_str("\r\n"); // отправляем символы перехода на новую строку

}

//-----------------------------------
