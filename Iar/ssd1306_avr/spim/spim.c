//------------------------------------------------------------------------------
// This is Open source software. You can place this code on your site, but don't
// forget a link to my YouTube-channel: https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Это программное обеспечение распространяется свободно. Вы можете размещать
// его на вашем сайте, но не забудьте указать ссылку на мой YouTube-канал 
// "Электроника в объектике" https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Автор: Надыршин Руслан / Nadyrshin Ruslan
//------------------------------------------------------------------------------
#include <ioavr.h>
#include <inavr.h>
#include "spim.h"


//==============================================================================
// Процедура инициализации spi в режиме master
//==============================================================================
void spim_init(void)
{
  // Настраиваем ножки сигналов SCK и MOSI. Их расположение перенастроить у AVR нельзя
  DDRB |= ((1 << 2) | (1 << 3) | (1 << 5));
  
  SPCR |= (1 << SPE) | (1 << MSTR);// | (1 << SPR0);
  SPSR |= (1 << SPI2X);
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 16-битных слов
//==============================================================================
void SPI_send16b(uint16_t *pBuff, uint16_t Len)
{
  for (uint16_t i = 0; i < Len; i++)
  {
    // Выдаём старший байт
    SPDR = (*pBuff) >> 8; 
    while (!(SPSR & (1 << SPIF)))  {}
    // Выдаём младший байт
    SPDR = (*pBuff) & 0xFF; 
    while (!(SPSR & (1 << SPIF)))  {}
    
    pBuff++;
  }
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов
//==============================================================================
void SPI_send8b(uint8_t *pBuff, uint16_t Len)
{
  for (uint16_t i = 0; i < Len; i++)
  {
    SPDR = *(pBuff++); 
    while (!(SPSR & (1 << SPIF)))  {}
  }
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 16-битных слов
//==============================================================================
void SPI_recv16b(uint16_t *pBuff, uint16_t Len)
{
  uint16_t tmp;
  
  for (uint16_t i = 0; i < Len; i++)
  {
   SPDR = 0x00;
   while(!(SPSR & (1<<SPIF)));
   tmp = (SPDR << 8);
   SPDR = 0x00;
   while(!(SPSR & (1<<SPIF)));
   tmp |= SPDR;
   
   *(pBuff++) = tmp;
  }
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов
//==============================================================================
void SPI_recv8b(uint8_t *pBuff, uint16_t Len)
{
  for (uint16_t i = 0; i < Len; i++)
  {
   SPDR = 0x00;
   while(!(SPSR & (1<<SPIF)));
   *(pBuff++) = SPDR;
  }
}
//==============================================================================
