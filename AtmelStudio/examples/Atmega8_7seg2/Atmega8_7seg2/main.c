#define F_CPU 1000000UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

uint8_t digit[]={63,6,91,79,102,109,125,7,127,111};// символы
uint8_t buf[4];// буфер индикации
uint8_t status;// статус индикации


//индикация 16 битного значения c точкой
void disp16(uint16_t n, uint8_t dot)
{
	// вычисление единиц, десятков... и заполнение буфера
	for(uint8_t i=0; i<4; i++)
	{
		buf[i] = digit[n%10];
		n/=10;
	}
	// отработка точки
	if (dot)
	{
		buf[dot-1]|=(1<<7);// включение точки в нужном разряде
	}
}


// обработчик прерывания по переполнению таймера 0. частота 488 Гц
ISR(TIMER0_OVF_vect){
	switch (status)
	{
		case 0:// нулевой разряд
		PORTB&=~(1<<PB7);// отключить предыдущий разряд
		PORTD=buf[0]; // загрузить символ из буфера в порт
		PORTB|=(1<<PB4);// включить разряд
		status=1;// переход в следующий статус
		break;
		
		case 1:// первый разряд
		PORTB&=~(1<<PB4);
		PORTD=buf[1];
		PORTB|=(1<<PB5);
		status=2;
		break;
		
		case 2:// второй разряд
		PORTB&=~(1<<PB5);
		PORTD=buf[2];
		PORTB|=(1<<PB6);
		status=3;
		break;
		
		case 3:// третий разряд
		PORTB&=~(1<<PB6);
		PORTD=buf[3];
		PORTB|=(1<<PB7);
		status=0;
		break;
	}
}

int main(void)
{
	// ---------------таймер 0------------------------------------
	TCCR0|=(1<<CS01);// делитель 8
	TIMSK|=(1<<TOIE0); // разрешить прерывание по переполнению
	//------------------------------------------------------------
	//--- пины для управления индикатором на выход----------------
	DDRD=255;
	DDRB|=(1<<PB4) | (1<<PB5) | (1<<PB6) | (1<<PB7);
	//------------------------------------------------------------
	sei();// глобально разрешить прерывания
	uint16_t i=0;
    while (1) 
    {
		if (i%2) disp16(i,1); // если i нечетное индикация с точкой
		else disp16(i,0);// иначе без точки
		_delay_ms(500);
		i++;
    }
}

