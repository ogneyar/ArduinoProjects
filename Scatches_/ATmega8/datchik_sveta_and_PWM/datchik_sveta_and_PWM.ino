// ATmega8

void settings(void) {
  DDRB|=(1<<PB3); // пин OC2 на выход (PB3) 17-pin // выход шим на диод
  DDRC&=~(1<<PC2); // пин ADC2 (PC2) на вход // датчик света
  DDRC&=~(1<<PC3); // пин ADC3 (PC3) на вход // регулятор
  // настройка таймера в режиме генерации ШИМ
  TCCR2|=(1<<WGM20) | (1<<WGM21); // fast pwm
  TCCR2|=(1<<COM21); // пин OC2 не инверсно
  TCCR2|=(1<<CS20); // без делителя
  OCR2=1;// начальная скважность.
  // настройка АЦП
  ADMUX|=(1<<ADLAR);// удобнее забирать 8-битный результат преобразования  
  ADMUX|=(1<<MUX1); // выбор канала ADC2 (PC2) 25-pin A2 // датчик света
  // ADMUX|=(1<<MUX0) | (1<<MUX1); // выбор канала ADC3 (PC3) 26-pin A3 // регулятор
  ADMUX|=(1<<REFS0); // AVCC внутри соединяется с AREF pin
  ADCSRA|=(1<<ADEN); // включить ацп
  ADCSRA|=(1<<ADPS2); // делитель 16
}


int main(void) {

  settings();
    
  while (1) {
    ADMUX|=(1<<MUX0); // опрос регулятора
    ADCSRA|=(1<<ADSC); // запуск преобразования
    while((ADCSRA&(1<<ADSC)));// ожидание окончания преобразования
    OCR2=ADCH/2;// в регистр сравнения записать результат преобразования 
    // _delay_ms(1);
    
    ADMUX&=~(1<<MUX0); // опрос датчика света
    ADCSRA|=(1<<ADSC); // запуск преобразования
    while((ADCSRA&(1<<ADSC)));// ожидание окончания преобразования
    if (ADCH < 100) DDRB|=(1<<PB3); // пин на выход
    else DDRB&=~(1<<PB3); // пин на вход, чтобы диод гас полностью
    // _delay_ms(1);
  }
}
